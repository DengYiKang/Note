# HTTP

## 状态码

+ 2XX

  + 200 OK
  + 204 No Content：响应头后没有 body 数据
  + 206 Partial Content：是 HTTP 分块下载或断点续传的基础，在客户端发送“范围请求”、要求获取资源的部分数据时出现，它与 200 一样，也是服务器成功处理了请求，但 body 里的数据不是资源的全部，而是其中的一部分。

+ 3XX：

  + 301 Moved Permanently：俗称“永久重定向”，含义是此次请求的资源已经不存在了，需要改用新的 URI 再次访问。

  + 302 Found：“临时重定向”，意思是请求的资源还在，但需要暂时用另一个 URI 来访问。

    >302不会做缓存优化，第二天访问时仍使用原地址。

  + 304 Not Modified：是一个比较有意思的状态码，它用于 If-Modified-Since 等条件请求，表示资源未修改，用于缓存控制。它不具有通常的跳转含义，但可以理解成“重定向已到缓存的文件”（即“缓存重定向”）。

+ 4XX：

  + 400 Bad Request：通用的错误码，表示请求报文有错误，是一个笼统的错误。
  + 403 Forbidden：禁止访问资源。原因可能多种多样，例如信息敏感、法律禁止等。
  + 404 Not Found：资源在本服务器上未找到，所以无法提供给客户端。

+ 5XX：

  + 500 Internal Server Error：通用的错误码。
  + 501 Not Implemented：客户端请求的功能还不支持。
  + 502 Bad Gateway：服务器作为网关或者代理时返回的错误码。
  + 503 Service Unavailable：服务器当前很忙，暂时无法响应服务，临时状态，有Retry-After字段，指示客户端可以在多久以后再次尝试发送请求。

## 特点

1、HTTP 最大的优点是简单、灵活和易于扩展；

2、HTTP 拥有成熟的软硬件环境，应用的非常广泛，是互联网的基础设施；

3、HTTP 是无状态的，可以轻松实现集群化，扩展性能，但有时也需要用 Cookie 技术来实现“有状态”；

4、HTTP 是明文传输，数据完全肉眼可见，能够方便地研究分析，但也容易被窃听；

5、HTTP 是不安全的，无法验证通信双方的身份，也不能判断报文是否被窜改；

6、HTTP 的性能不算差，但不完全适应现在的互联网，还有很大的提升空间。

## get/head, post/put

head:只会传回响应头，也就是资源的“元信息”,比如，想要检查一个文件是否存在，只要发个 HEAD 请求就可以了。

GET 和 HEAD 既是安全的也是幂等的，DELETE 可以多次删除同一个资源，效果都是“资源不存在”，所以也是幂等的。

POST 是“新增或提交数据”，多次提交数据会创建多个资源，所以不是幂等的；而 PUT 是“替换或更新数据”，多次更新一个资源，资源还是会第一次更新的状态，所以是幂等的。

## 实体数据

+ 数据类型表示实体数据的内容是什么，使用的是 MIME type，相关的头字段是 Accept 和 Content-Type；
+ 数据编码表示实体数据的压缩方式，相关的头字段是 Accept-Encoding 和 Content-Encoding；
+ 语言类型表示实体数据的自然语言，相关的头字段是 Accept-Language 和 Content-Language；
+ 字符集表示实体数据的编码方式，相关的头字段是 Accept-Charset 和 Content-Type；
+ 客户端需要在请求头里使用 Accept 等头字段与服务器进行“内容协商”，要求服务器返回最合适的数据；
+ Accept 等头字段可以用“,”顺序列出多个可能的选项，还可以用“;q=”参数来精确指定权重。

## 大文件

+ 压缩 HTML 等文本文件是传输大文件最基本的方法；
+ 分块传输可以流式收发数据，节约内存和带宽，使用响应头字段“Transfer-Encoding: chunked”来表示，分块的格式是 16 进制长度头 + 数据块；
+ 范围请求可以只获取部分数据，即“分块请求”，实现视频拖拽或者断点续传，使用请求头字段“Range”和响应头字段“Content-Range”，响应状态码必须是 206；
+ 也可以一次请求多个范围，这时候响应报文的数据类型是“multipart/byteranges”，body 里的多个部分会用 boundary 字符串分隔。

## 连接管理

+ 早期的 HTTP 协议使用短连接，收到响应后就立即关闭连接，效率很低；
+ HTTP/1.1 默认启用长连接，在一个连接上收发多个请求响应，提高了传输效率；
+ 服务器会发送“Connection: keep-alive”字段表示启用了长连接；
+ 报文头里如果有“Connection: close”就意味着长连接即将关闭；
+ 过多的长连接会占用服务器资源，所以服务器会用一些策略有选择地关闭长连接；
+ “队头阻塞”问题会导致性能下降，可以用“并发连接”和“域名分片”技术缓解。

## 缓存控制

+ no-store：不允许缓存，用于某些变化非常频繁的数据，例如秒杀页面；
+ no-cache：它的字面含义容易与 no-store 搞混，实际的意思并不是不允许缓存，而是可以缓存，但在使用之前必须要去服务器验证是否过期，是否有最新的版本；
+ must-revalidate：又是一个和 no-cache 相似的词，它的意思是如果缓存不过期就可以继续使用，但过期了如果还想用就必须去服务器验证。
+ 缓存是优化系统性能的重要手段，HTTP 传输的每一个环节中都可以有缓存；
+ 服务器使用“Cache-Control”设置缓存策略，常用的是“max-age”，表示资源的有效期；
+ 浏览器收到数据就会存入缓存，如果没过期就可以直接使用，过期就要去服务器验证是否仍然可用；
+ 验证资源是否失效需要使用“条件请求”，常用的是“if-Modified-Since”和“If-None-Match”，收到 304 就可以复用缓存里的资源；
+ 验证资源是否被修改的条件有两个：“Last-modified”和“ETag”，需要服务器预先在响应报文里设置，搭配条件请求使用；
+ 浏览器也可以发送“Cache-Control”字段，使用“max-age=0”或“no_cache”刷新数据。
+ <img src="..\pic\515.png" alt="img" style="zoom: 80%;" />

## HTTP2

+ HTTP/2 使用“HPACK”算法压缩头部信息，消除冗余数据节约带宽；
+ HTTP/2 的消息不再是“Header+Body”的形式，而是分散为多个二进制“帧”；
+ HTTP/2 使用虚拟的“流”传输消息，解决了困扰多年的“队头阻塞”问题，同时实现了“多路复用”，提高连接的利用率；
+ HTTP/2 也增强了安全性，要求至少是 TLS1.2，而且禁用了很多不安全的密码套件。
+ HTTP/2 把报文切分为多种类型的二进制帧，报头里最重要的字段是流标识符，标记帧属于哪个流；流是 HTTP/2 虚拟的概念，是帧的双向传输序列，相当于 HTTP/1 里的一次“请求 - 应答”；在一个 HTTP/2 连接上可以并发多个流，也就是多个“请求 - 响应”报文，这就是“多路复用”。

## http1.1的长连接和http2.0的多路复用到底有什么区别？

+ 长连接：同一个域名访问同一个文件的多个请求都可以复用一个tcp连接（不用像1.0一样 每次请求都需要重新建立连接）
  + 依然存在的问题：
    + 多个请求只能被串行处理（数据基于文本，只能按顺序传输）
    + 访问多个不同的文件依然会建立多个请求。
+ 多路复用：同一个域名访问多个文件的请求也可以复用一个tcp连接，且多个请求可以被并行处理。
  + 并行实现原理：http2.0引入二进制数据帧和流的概念（数据帧对每一个数据进行标识，可以不按顺序传输，从而实现并行）