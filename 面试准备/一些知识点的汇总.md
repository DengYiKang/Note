# 一些知识点的汇总

## 计算机网络

### 分层

<img src="../pic/413.jpg" alt="图片描述" style="zoom:80%;" />

### 传输控制协议TCP简介

+ 面向连接、可靠的、基于字节流的传输层通信协议
+ 将应用层的数据流分割成报文段并发送给目标节点的TCP层
+ 数据包都有序号，对方收到则发送ACK确认，未收到则重传
+ 使用校验和（？）来检验数据在传输过程中是否有误

### TCP Flags

+ URG：紧急指针标志，一般和紧急指针（16位）部分配合使用，紧急指针可以定位紧急数据的位置。
+ ACK：确认序号标志，为1表示确认，为0表示未含确认信息
+ PSH：push标志，为1指示接收方在接受到这个报文后应尽快上交给应用程序
+ RST：重置连接装置标志，用于重置由于主机崩溃或者其他原因而出现错误的连接，或者拒绝非法的报文段，或者拒绝连接
+ SYN：同步序号，用于建立连接过程。在连接请求中，SYN=1,ACK=0表示这个数据段没有使用捎带的确认域
+ FIN：finish标志，用于释放连接

### 三次握手

![](../pic/414.png)

#### 为什么需要三次握手才能建立起连接？

为了初始化Sequence Number的初始值，需要互相通知对方自己的Sequence值，这些Sequence要作为以后数据通信的序号，以保证各自接受到的数据不会因为网络波动等原因而乱序，TCP会用这些序号来拼接数据，这是前两次握手的作用。第三次握手就是client通知server自己已经收到，如果server没有收到，那么将会重试第二次握手。

### 首次握手的隐患——SYN超时

#### 问题起因分析

+ server收到client的SYN，回复SYN-ACK的时候未收到ACK确认
+ server不断重试直到超时，linux默认等待63秒才断开连接

#### SYN Flood

Dos攻击。某个恶意程序给server发一个SYN报文，发完后立即下线，那么server会默认等63秒才会断开这个连接，那么攻击者就会将server的连接队列耗尽，使得不能处理正常的连接请求。

#### 针对SYN Flood的防护措施

SYN Cookie是对TCP服务器端的三次握手协议三次握手协议作一些修改，专门用来防范SYN Flood攻击的一种手段。它的原理是，在TCP服务器收到TCP SYN包并返回TCP SYN+ACK包时，不分配一个专门的数据区，而是根据这个SYN包计算出一个cookie值。在收到TCP ACK包时，TCP服务器再根据那个cookie值检查这个TCP ACK包的合法性。如果合法，再分配专门的数据区进行处理未来的TCP连接。

#### 建立连接后，client出现故障怎么办

保活机制：

+ 向对方发送保活探测报文，如果未收到响应则继续发送
+ 尝试次数达到上限就断开连接

### TCP四次挥手

<img src="../pic/415.png" style="zoom:80%;" />

#### 为什么有TIME-WAIT状态

+ 确保有足够的时间让对方收到ACK包。
+ 避免新旧连接混淆，因为存在连接重用的可能，因此这些延迟收到的包可能会跟新的包混在一起。

#### 为什么需要四次握手才能断开连接

因为全双工，发送方和接受放都需要FIN报文和ACK报文。

而一方没有数据发送了，另一方可能还有数据没有发送，因此需要分别进行两次挥手。总共四次。

#### 服务器出现大量CLOSE_WAIT状态的原因

客户端发送FIN报文给服务器，而服务器没有发送ACK；或者服务器一直没有发送FIN报文。

最常见的原因是对方关闭socket连接，我方忙于读或写，没有及时关闭连接。

### UDP

#### 特点

+ 面向非连接
+ 不维护连接状态，支持同时向多个客户端传输相同的消息
+ 数据包报头子只有8个字节，相比TCP 20个，开销很小
+ 吞吐量不受拥挤算法的调节，只受限于数据生成速率、传输速率以及机器性能
+ 尽最大努力交付，不保证可靠交付，不需要维持复杂的链接状态表
+ 面向报文，不对应用程序提交的报文信息进行拆分或者合并

### TCP和UDP的区别

+ 面向连接vs无连接
+ 可靠性
+ 有序性
+ 速度
+ 量级，体现在头部大小

### TCP的滑动窗口

RTT和RTO：

+ RTT：发送一个数据包到收到对应的ACK，所花费的时间
+ RTO：重传时间间隔

TCP使用滑动窗口做流量控制和乱序重排。

<img src="../pic/416.png" style="zoom:80%;" />

AdvertisedWindow表示接收方还能再接受多少数据；EffectiveWindow表示发送方还能再发送多少数据。

### HTTP

超文本传输协议。

#### 特点

+ 支持客户/服务器模式（请求响应模型）
+ 简单快速，客户端向服务器传输数据时，只需要传输请求方法和路径
+ 灵活
+ 无连接。每次连接只处理一个请求，做出了应答就断开连接，节省传输时间。但是从HTTP 1.1起，默认使用长连接（与close相对应），即服务器等待一定时间才断开。
+ 无状态。

> HTTP1.1相较于1.0，引入了keep-alive。

#### 请求/响应的步骤

+ 客户端链接到Web服务器
+ 发送HTTP请求
+ 服务器接受请求并返回HTTP响应
+ 释放连接TCP连接
+ 客户端浏览器解析HTML内容

#### 在浏览器地址栏输入URL，按下回车之后的流程？

+ DNS解析（从近到远依次是浏览器缓存、系统缓存、路由器缓存、IPS服务器缓存、根域名服务器缓存，顶级域名服务器缓存）
+ TCP连接（三次握手）
+ 发送HTTP请求
+ 服务器处理请求并返回HTTP报文
+ 浏览器解析渲染页面
+ 连接结束（四次挥手）

#### HTTP状态码？

五种可能的取值：

+ 1xx：指示信息——表示请求已接受，继续处理
+ 2xx：成功——表示请求已被成功接受
+ 3xx：重定向——要完成请求必须进行更进一步的操作
+ 4xx：客户端错误——请求由语法错误或请求无法实现
+ 5xx：服务器端错误——服务器未能实现合法的请求

#### 常见的HTTP状态码

+ 200 OK：正常返回信息
+ 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
+ 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
+ 403 Forbidden：服务器收到请求，但是拒绝提供服务（例如，访问IP被禁止）
+ 404 Not Found：请求资源不存在，eg，输入了错误的URL
+ 500 Internal Server Error：服务器发生不可预期的错误
+ 503 Server Unavailable：服务器当前不能处理客户端的请求，一段时间后可能回复正常

#### GET请求和POST请求的区别

从三个层面来解答：

+ Http报文层面：GET将请求信息放在URL，POST信息放在报文体中，抓包还是能抓出明文账号密码等
+ 数据库层面：GET符合幂等性（一般做查询用），POST不符合
+ 其他层面：GET可以被缓存（如浏览器的浏览记录中），而POST不行

#### Cookie和Session

Cookie：

+ 是由服务器发给客户端的特殊信息（放在请求头），以文本的形式存放在客户端
+ 客户端再次请求的时候，会把cookie回复
+ 服务器接受到后，回揭西cookie生成与客户端相对应的内容

Cookie的设置以及发送过程：

<img src="../pic/417.png" style="zoom:80%;" />

Sessoin：

+ 服务器端的机制，在服务器上保存的信息
+ 解析客户端请求并操作session id，按序保存状态信息

Session的实现方式：

+ 使用cookie来实现：

  服务器给每个cookie分配一个session id，即jsessionid，然后发给客户，客户在后续请求中，将这个id携带在cookie中，发给服务端。

  <img src="../pic/418.png" style="zoom:80%;" />

+ 使用URL回写来实现：服务器发送给浏览器的链接中携带jsessionid的参数，客户端点击任何链接，都会将这个id带回到服务器。

> Tomcat支持两种，如果发现客户端支持cookie，那么就用cookie。

#### Cookie和Session的区别

+ Cookie数据存放在客户的浏览器上，Session数据放在服务器上
+ Session相比Cookie更安全，因为Cookie存放在用户本地，可以被获取并分析。
+ 如果考虑减轻服务器负担，应当使用Cookie。

### HTTP和HTTPS的区别

<img src="../pic/419.png" style="zoom:80%;" />

#### SSL(Security Sockets Layer，安全套接层)

+ 为网络通信提供安全及数据完整性的一种安全协议
+ 是操作系统对外的API，SSL3.0后更名为TLS
+ 采用身份验证和数据加密保证网络通信的安全和数据的完整性

#### 加密方式

+ 对称加密：加密和解密都使用同一个密钥

+ 非对称加密：加密使用的密钥和解密使用的密钥是不相同的

+ 哈希算法：将任意长度的信息转换为固定长度的值，算法不可逆

+ 数字签名：证明某个消息或者文件是某人发出/认同的（证明没有被修改过）

  > 数字签名：
  >
  > （1）甲使用乙的公钥对明文进行加密，生成密文信息。
  >
  > （2）甲使用HASH算法对明文进行HASH运算，生成数字指纹。
  >
  > （3）甲使用自己的私钥对数字指纹进行加密，生成数字签名。
  >
  > （4）甲将密文信息和数字签名一起发送给乙。
  >
  > （5）乙使用甲的公钥对数字签名进行解密，得到数字指纹。
  >
  > （6）乙接收到甲的加密信息后，使用自己的私钥对密文信息进行解密，得到最初的明文。
  >
  > （7）乙使用HASH算法对还原出的明文用与甲所使用的相同HASH算法进行HASH运算，生成数字指纹。然后乙将生成的数字指纹与从甲得到的数字指纹进行比较，如果一致，乙接受明文；如果不一致，乙丢弃明文。
  >
  > 
  >
  > 非对称加密和数字签名的区别：
  >
  > 对于非对称加密，**整个数据加密和解密过程用的都是接收方的密钥**，而数字签名则完全相反，**整个数据签名和解密的过程用的都是发送方的密钥**。

#### HTTPS证书

在服务器上生成CSR文件（证书申请文件，内容包括证书公钥、使用的Hash算法、申请的域名、公司名称、职位等信息），把CSR文件和其他可能的证件上传到CA认证机构，CA机构收到证书申请之后，使用申请中的Hash算法，对部分内容进行摘要，然后`使用CA机构自己的私钥对这段摘要信息进行签名`， 然后CA机构把签名过的证书通过邮件形式发送到申请者手中。申请者收到证书之后部署到自己的web服务器中。

浏览器端拥有CA的公钥，在获取到服务器发来的证书后，对签名进行解密，得到摘要1，然后对其他信息进行hash，得到摘要2，比对这两个摘要，如果不一致，那么不可信。

#### HTTPS流程

+ 浏览器将支持的加密算法信息发送给服务器
+ 服务器选择一套浏览器支持的加密算法，以证书的形式回发给浏览器
+ 浏览器验证证书合法性，然后做以下操作：
  + 定义一个握手信息，使用哈希算法进行加密，得到A
  + 生成随机的对称加密的密码，使用服务器的公钥进行加密，得到B
  + 用随机生成的密码对A进行对称加密，得到C
  + 将A，B，C发给server
+ server端进行验证，具体操作如下：
  + 使用server端的私钥对B进行解密，得到对称密钥
  + 使用上述的对称密钥对C进行解密，得到被哈希过的握手信息
  + 将这个握手信息与A进行比对，如果一致，则消息合法
+ 如果上述消息合法，server端使用上述对称密钥加密新的握手信息，发送给浏览器
+ 浏览器用对称密钥解密握手信息，然后计算握手信息的哈希值，如果与服务端发来的相同，那么消息合法
+ 之后就使用浏览器生成的随机密码和对称加密算法传输数据了

#### HTTP和HTTPS的区别

+ HTTPS需要到CA申请证书，HTTP不需要
+ HTTPS密文传输，HTTP明文传输
+ 连接方式不同，HTTPS默认443端口，HTTP使用80端口
+ HTTPS=HTTP+加密+认证+完整性保护，较HTTP安全

#### HTTPS真的安全吗

+ 浏览器默认填充http://，请求需要进行跳转，有被劫持的风险
+ 可以使用HSTS（HTTP Strict Transport Security）优化

### Socket简介

Sockt是对TCP/IP协议的抽象，方便于使用TCP/IP协议栈。是操作系统对外开放的接口。

![](../pic/421.png)

## 数据库

### 如何设计一个关系型数据库？

![](../pic/422.png)

### 索引模块

#### 什么样的信息能成为索引

+ 主键、唯一键以及普通键等

