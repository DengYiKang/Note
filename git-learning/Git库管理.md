# Git库管理

一些有趣的问题：

+ 从网上克隆来的版本库，为什么在对象库中找不到对象文件？而且引用目录里也看不到所有的引用文件？
+ 不小心添加了一个大文件到Git库中，用重置命令丢弃了包含大文件的提交，可是版本库不见小，大文件仍在对象库中。
+ 本地版本库的对象库里文件越来越多，这可能导致Git性能的降低。

## 对象与引用的去向

进入一个克隆的版本库，可用git show-ref显示所含的引用：

![image-20191024102332924](pic/image-20191024102332924.png)

其中refs/heads/开头的是分支；以refs/remotes/开头的是远程版本库分支在本地的映射；以refs/tags/开头的是tag。

寻找对应文件，发现只有HEAD和master：

![image-20191024102716734](pic/image-20191024102716734.png)

其实这些引用文件都被打包放在.git/packed-refs中。

![image-20191024103215729](pic/image-20191024103215729.png)

而对于Git对象（commit、blob、tree、tag）在对象库中的存储：

![image-20191024103424621](pic/image-20191024103424621.png)

所有的对象文件都被打包到这两个文件中了。其中以<.pack>结尾的文件是打包文件，以<.idx>结尾的是索引文件。Git对于以SHA1哈希值作为目录名和文件名保存的对象有一个术语，称为松散对象。松散对象打包后会提高访问效率，而且不同的对象可以通过增量存储节省磁盘空间。

可以用git show-index查看：

![image-20191024103918166](pic/image-20191024103918166.png)

克隆之后的版本库在日常提交中，产生的新对象仍旧以松散对象存在，而不是以打包形式。松散对象只是进行了压缩，而没有（打包文件才有的）增量存储的功能，会浪费空间，也会降低访问效率。

## 暂存区操作引入的临时对象

暂存区操作有可能在对象库中产生临时对象，例如文件反复的修改和反复的向暂存区添加，或者添加到暂存区后不提交甚至直接撤销，就会产生垃圾数据占用磁盘空间。

```bash
#查看空间占用
du -sh
du -sh .git/
#标识为dangling的对象是没有被任何引用直接或者间接关联到的对象。
git fsck
#清理
git prune
```

## 重置操作引入的对象

用git prune命令清除暂存区操作时引入的临时对象，但是如果是用重置命令抛弃的提交和文件不会被清除。

实际上，撤销的操作需要记录在reflog中，Git认为撤销的提交和大文件都还可以被追踪到，还在使用着，所以无法使用git prune删除。

如果确认要丢弃不想要的对象，需要对版本库的reflog做过期处理，相当于将<.git/logs/>下的文件清空。

