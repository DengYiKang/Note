# 源码总结

## JUC

### CAS

+ 存在ABA问题，CAS只能保证两个时刻的某个位置上的值是一致的，而不能保证在这之间的时间段里，该位置的值没有发生变化。

### AtomicIntegerArray

+ array变量用final修饰，但注意没有用volatile修饰！其实是通过调用Unsafe类的getIntVolatile以及putIntVolatile方法来保证的。

### AtomicIntegerFieldUpdater

+ 基于反射，能够提供对指定类的指定的volatile int字段的原子更新操作。
+ FieldUpdater vs AtomicXXX
	+ 使用FieldUpdater可以避免引入Atomic类。
	+ 当需要构造出大量需要保证线程安全的对象时，可以仅仅将对应的域设置为volatile的，用FieldUpdater进行同一操作，而不是将AtomicXXX嵌入其中。

### AtomicMarkableReference

+ AtomicMarkableReference与AtomicStampledReference非常类似。前者维护二元组[reference, boolean]，后者维护二元组[reference, int]。
+ 提供了对二元组的CAS操作。

### Striped64

+ 当大量线程需要访问同一个Atomic类时，虽然能满足原子语义，但是吞吐量会大大下降。
+ 对于更新操作，用“分摊”的思想，将这些操作分摊到多个Cell上，在每个Cell上使用CAS，需要总和时，只需要将它们累加返回。
+ Cell使用了@Contended注解，因为Striped64里维护了Cell数组，需要引入paddings来解决FalseSharing的问题。
+ Cell数组使用懒初始化的方式，长度为$2^n$，用于hash&(len-1)，即取hash值的末n bit。
+ 优先CAS更新base，失败后再去CAS更新相应的cell。
+ 在执行初始化、扩展、竞争等操作时，采用的是自旋锁的机制，即volatile类型的cellBusy变量，对它的CAS操作+自旋。

### AQS

+ 一般地，在入队之前会尝试请求一次锁，即tryAcquire方法，根据tryAcquire的不同实现可以得到很多策略，例如公平锁与非公平锁。比如在tryAcquire中通过判断队列是否非空做相应处理来实现公平锁。
+ 在高并发的情况下，非公平锁的性能大于公平锁。对于非公平锁，一个新来的线程如果tryAcquire成功，那么直接就可以执行。对于公平锁，需要进行若干个操作（如对队列的操作、唤醒等调度）才能开始执行。当公平锁可能会导致饥饿问题。
+ 队列有两种，同步队列与条件队列。
+ 对于一个AQS来说，一个AQS的所有条件队列都对应同一个同步队列。一个AQS只能有一个同步队列，而能有多个条件队列。
+ 同步队列的底层实现是双向链表；条件队列的底层实现是单向链表。
+ Node类的next与pre域用于同步队列，nextwaiter用于条件队列（在同步队列中，nextwaiter最多在共享模式下用来标识是否为共享锁节点）。
+ 当一个节点成功地acquire的时候，它就成为了首节点，因此首节点永远不会是取消状态的节点。
+ Node有四种状态：
	+ CANCELLED：表示该Node已经被取消
	+ SIGNAL：表示后继需要被唤醒。一个Node只有在前驱的状态设置为SIGNAL后才具备挂起的条件
	+ CONDITION：表示是从条件队列出队（被signal，唤醒去竞争锁），入队到同步队列的
	+ PROPAGATE：只用于共享锁模式，用于判断需不需要多唤醒一个线程取竞争锁
+ 同步队列的next域在入队操作时不会被初始化，只有它被用到时才会。因此不能通过next域来判断是否为tail节点。因此如果某个节点的next域为空，我们可以查看tail的prev节点进行二次检查。pre节点是准确的！
+ 独占锁的获取：acquire
	+ 首先会调用tryAcquire，在入队前尝试获取锁。
	+ tryAcquire失败，那么将调用acquireQueued进行自旋，再次尝试获取，失败则入队挂起。
	+ acquireQueued会不断自旋，直到获取锁成功，先判断是否当前节点是否具有挂起条件（前驱为SIGNAL），如果前驱不是SIGNAL，那么将前驱设置为SIGNAL，下次循环再挂起当前节点。
	+ 在acquireQueued中的自旋中，获取锁的方式是公平的。在非公平锁中，当线程A被唤醒重新去竞争锁，而另一个新来的线程B非公平地先获取了锁，线程A获取锁失败，再度被挂起。
+ 独占锁的释放：release
	+ 调用tryRelease，成功后判断是否需要唤醒后继结点，失败直接返回。
	+ tryRelease成功后，检查head如果为SIGNAL，那么唤醒后继。
+ 共享锁的获取：acquireShared
	+ 首先调用tryAcquireShared，成功就返回，失败就调用doAcquireShared，这个整体逻辑跟acquireQueued差不多，直到获取锁成功。
	+ 共享锁在获取成功后的处理与独占锁不同的是，会检查head的后继是否也能获取锁，如果能就unpark它。
+ 共享锁的释放：releaseShared
	+ 首先调用tryReleaseShared。
	+ 如果tryReleaseShared成功，检查head状态，如果为SIGNAL，那么置为0，唤醒后继；如果head为0，那么置为PROPAGATE。
+ PROPAGATE
	+ 用于共享锁
	+ 什么时候head的状态会是PROPAGETE呢？当有多个线程同时进行release操作时，两次release会将head从SIGNAL变为0再变为PROPAGATE。由于并发，在setHeadAndPropagate方法里面的临时变量propagate（表示还剩多少锁资源）可能与实际情况不一致。比如propagete=0，没锁资源了，就唤醒后继了，但是同时有别的线程release了，因此实际可能为1。为了处理这种情况，可以判断旧head的状态是否为PROPAGETE，如果为PROPAGATE，那么意味着在读取propagate之后又有新的线程release了，那么就再唤醒一个后继。
+ Condition
	+ await
		+ 首先将当前线程入队条件队列
		+ 释放所有的锁，将锁的数量保存下来，在被唤醒后重新请求相同数量的锁
		+ 自旋判断是否在同步队列上，如果不在就阻塞自己
		+ 当阻塞中的自己被中断或者被signal唤醒，将调用acquireQueued去竞争锁，失败将进入同步队列
	+ signal
		+ 将条件队列的第一个唤醒并入队同步队列，唤醒与入队的操作可以失败，失败表示中断流程先行发生，后续的acquireQueued也会使节点入队同步队列。

### ReentrantLock

+ 重入锁是一个独占锁，可重入指的是当某个线程持有锁时，它可以acquire多次。即当state=0时，没有线程持有锁，当不等于0时，某个线程持有锁，且这个线程acquire了state次。
+ 只是简单地实现了AQS的tryAcquire和tryRelease方法

### ReentrantReadWriteLock

+ 默认模式是非公平的。

+ 定义了两把锁，读锁与写锁，它们共用一个同步队列，即同一个AQS的子类实现。
+ AQS的state为Integer类型，高16 bit为读锁的拥有数量，低16 bit为写锁的拥有数量。
+ 需要记录各个线程的读锁的拥有数量。用HoldCounter类包装一个整型变量count，再与ThreadLocal相结合作为线程私有的。写锁不需要记录，因为只能有一个线程持有锁，至于重入数量直接查看state即可。
+ 写锁
	+ tryRelease
		+ 如果当前线程未持有锁，那么抛出异常
		+ 释放后如果写锁的state为0，那么将exclusiveOwner置null
		+ 没有用自旋，因为写锁只能由一个线程持有，没有竞争
	+ tryAcquire
		+ 读锁数量必须为0
		+ 写锁可以非0，但必须保证当前线程是独占线程
		+ 如果获取后写锁数量溢出，则抛出异常
+ 读锁
	+ tryReleaseShared
		+ 就是简单的将ThreadLocal存着的count减一。最后对state的CAS有自旋。
	+ tryAcquireShared
		+ 写锁必须为0，或者当前线程持有锁
		+ 同样需要自旋
	+ 可以注意到，独占锁的tryXXX方法不需要自旋，因为持锁的有线程只能有一个；而共享锁的tryXXX方法需要自旋，因为持有锁的线程可能有多个。
+ 总结
	+ 一个线程具备获取写锁的条件
		+ 读锁为0
		+ 写锁获取不超过上限
		+ 写锁为0或者当前线程为写锁的独占线程
		+ 公平模式下为head的后继，非公平无所谓
	+ 一个线程具备获取读锁的条件
		+ 当前写锁为0或者当前线程持有写锁
		+ 读锁获取不超过上限
		+ 如果当前线程持有读锁，那么在公平模式下即使不为head后继也允许获取
		+ 如果当前线程不持有读锁，且在非公平模式下不为head后继，那么只能排队等待

### CountDownLatch

+ 基于共享锁，一次性。
+ state初始化时为n，调用countDown方法->releaseShared->tryReleaseShared，将state减一。
+ 某个线程调用await方法->调用acquireShared(1)进行阻塞式抢锁。而只有当state为0时，tryAcquireShared才会返回true。
+ 当调用最后一次的countDown方法将state变为0时，此前所有请求锁的线程必定已经阻塞在同步队列上的，countDown->releaseShared->唤醒第一个线程抢锁->state为0，tryAcquireShared抢锁成功->setHeadAndPropagate->唤醒第二个线程（因为tryAcquireShared返回的都是1）->......->直到唤醒最后一个线程
+ 应用场景：
	+ n等1：
		+ n个线程调用await，一个线程调用countDown，state初始化为1
	+ 1等n：
		+ n个线程调用countDown，一个线程调用await，state初始化为n

### CyclicBarrier

+ CountDownLatch只使用了同步队列，而CyclicBarrier既使用了同步队列也使用了条件队列。
+ CountDownLatch基于共享锁，而CyclicBarrier基于独占锁，非公平。
+ CountDownLatch一般用于两个场景：n等1与1等n。而CyclicBarrier强化了第二种场景，前n-1个线程到达屏障后等待，直到第n个线程到达屏障，当所有n个线程到达屏障时，可以执行用户传入的某项任务，然后对所有的线程进行signal，依次唤醒，后执行。
+ CountDownLatch只能使用一次；CyclicBarrier可以使用多次，每次为不同的generation。
+ CyclicBarrier遵循`all-or-none breakage model`的原则，同一代线程要么都正常在`CyclicBarrier#await`返回，要么都抛出异常(某个线程超时、中断将设置broken为true，其他线程会抛出broken异常)。
+ 使用了一个独占锁和对应锁的一个条件队列。
+ generation变量代表一个代，用于存储是否broken的标志以及比较generation是否发生改变。
+ count变量表示还需要多少个线程到达屏障。线程调用await，获取独占锁，修改count，如果当前线程不是最后一个到达的线程，那么调用AQS的await阻塞等待；如果当前线程是最后一个到达的，那么无需阻塞，直接执行用户传入的某项任务，完毕后调动nextGeneration->signalAll。
+ 一代线程通过屏障的完整流程
	+ 前n-1个线程到达屏障，将count减一，然后调用Codition的await阻塞。此时前n-1个线程处于条件队列上。
	+ 第n个线程达到屏障，将count减到0，然后执行barrierCommand，如果command执行成功，那么nextGeneration->signalAll；如果失败，将broken设置为true，signalAll，其他n-1个线程一次获取锁，发现broken为true，抛出异常。
	+ 综上，n个线程要么都做要么都不做。
+ 前n-1个线程发生中断或超时的流程
	+ 当某个线程发生中断或超时时，调用breakBarrier，设置broken为true，signalAll，其他所有的线程一次获取锁，检测到broken，都抛出异常。
+ 第n个线程执行nextGeneration之前或之后，前面的线程发生中断或超时
	+ 因为第n个线程全程持有锁，因此之前与之后的情况是一样的。
	+ 第n个线程调用nextGeneration后，对于前面的n-1个线程，当前代肯定不是最新代了，就不会执行breakBarrier，因此正常退出。
	+ 综上，第n个线程到达的那一刻，只要第n个线程没有发生异常，这n个线程都能正常退出。
+ 条件队列上的node的线程，肯定是同一代的吗？
	+ 是的，换代只有nextGeneration能换，且还会调用signalAll，将条件队列上的所有线程入队同步队列。
+ 同步队列上的node线程，肯定是同一代的吗？
	+ 不一定。因为是非公平方式。第n个线程调用了nextGeneration后，前n-1个线程入队同步队列，它们是第一代。现在第二代的n个线程到来，因为非公平的方式，它们可能会先获得锁，最极端的情况就是第二代的线程都抢锁成功，那么同步队列里面存在着两种不同的代。

### Semaphore

+ 默认实现是非公平共享锁。
+ tryXXX等方法使用乐观锁（自旋+CAS）。
+ permit数量就是AQS的state。
+ 提供减少permit总量的方法。
+ 提供清空当前所剩的permit的方法。
+ 其他的方法都是对AQS对应的方法的包装。

### ThreadLocal

+ 这个类提供线程本地变量。各个线程通过该类的get/set方法来访问线程隔离的变量。表面上看好像是ThreadLocal维护了一个变量表，存储着各个线程的同一个变量名的不同版本，事实上该变量是存储在各个线程内的map中的。一个线程得到一个ThreadLocal实例时，将ThreadLocal实例作为map中的key去访问本地的map，得到本地的ThreadLocal实例对应的变量。

+ 例子：

	```java
	//给各个线程标记id，不可改动（可以开放set方法来允许线程改动自身id） 
	public class ThreadId {
	     //提供初始化的数值
	     private static final AtomicInteger nextId = new AtomicInteger(0);
	
	     //ThreadLocal变量
	     private static final ThreadLocal<Integer> threadId =
	         new ThreadLocal<Integer>() {
	         //当某个线程调用thread_local.get()时，如果key没有对应的值，那么将调用initialValue()方法
	             @Override protected Integer initialValue() {
	                 return nextId.getAndIncrement();
	         }
	     };
	
	     //get方法
	     public static int get() {
	         return threadId.get();
	     }
	 }
	```

+ 每一个ThreadLocal类型的实例都保存着不一样的threadLocalHashCode，作为各个线程的threadLocals（ThreadLocalMap类型）的key。因此就算是同一个ThreadLocal类型，如果实例不一样，那么线程私有的map中的对应值也是不一样的。
+ initialValue()
	+ 当某个线程调用thread_local.get()时，如果key没有对应的值，那么将调用initialValue()方法
+ get()
	+ 在线程A中调用ThreadLocal实例的get方法时，首先会获取当前线程A的ThreadLocalMap，然后将ThreadLocal实例本身的hash&(capacity-1)作为key到ThreadLocalMap中查找，如果没有对应的key，那么设置为initialValue()。
+ set()
	+ 就是当前线程的ThreadLocalMap的set方法的包装。
+ ThreadLocalMap
	+ 该类是在ThreadLocal类中定义的。
	+ 底层是个Entry数组table，做环形数组用。
	+ Entry继承了WeakReference，WeakReference的referent类型为ThreadLocal<?>，就是前面提到的ThreadLocal实例的类型，做为key。
	+ table的初始容量为16，为2的幂
	+ hash冲突时进行线性探测。探测函数使得table为一个环形数组。
	+ 探测的同时会整理table。
		+ 在Miss后，线性探测，在探测的途中如果遇到了stale entry会整理table。stale entry指的是非null的slot，但是key为null。
		+ expungeStaleEntry是清理函数。整理对象是都从哪个staleSlot开始的非null连续段，将staleSlot置null。每次遇见不是staleSlot的slot，重新计算hash值，因为前面清理过的slot可能恰好可以作为它们的新位置。清理函数都是类似的逻辑。
		+ 清理机制能保证待搜索的位置一定在以hash值下标为首的连续段中，提高了搜索效率。
	+ get、set都可能进行整理。
	+ 两倍扩容。
	+ 当所用量大于1/2时，将进行扩容。
+ 应用场景：
	+ ThreadLocal用来给各个线程提供线程隔离的局部变量。使用很简单，通过调用同一个ThreadLocal对象的get/set方法来读写这个ThreadLocal对象对应的value。
	+ ThreadLocal对象通常是`static`的，因为它在map里作为key使用，所以在各个线程中需要复用。
+ 为什么Entry继承了WeakReference？
	+ 首先，WeakReference的父类成员referent，如果referent指向的对象没有强引用指着它，那么referent指向的对象就可能被回收，从而使得referent引用为null。
	+ 如果不继承WeakReference，而仅仅将ThreadLocal的实例设为null，那么在各个线程的ThreadLocalMap中，某个entry还持有着该ThreadLocal对象，是强引用，因此除非所有的线程执行remove或者退出，这些entry永远不会被gc。
	+ 如果继承了WeakReference，然后将ThreadLocal的实例设为null，那么该实例只剩下各个线程的map中的entry的弱引用了，随时可能被gc。当被gc时，entry的key变为null，变成了staleSlot，ThreadLocalMap的get、set方法发现它们会自动帮忙清理。
	+ 如果当前线程用不到这个值时，建议显示调用remove。

