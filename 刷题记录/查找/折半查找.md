# 折半查找

```java
int binarySearch(int x, int[] A){
    Arrays.sort(A);
    int left=0, right=A.length-1, mid;
    while(left<=right){
        mid=(left+right)/2;
        if(A[mid]<x) left=mid+1;
        else if(A[mid]>x) right=mid-1;
        else break;
	}
    return mid;
}
```

```java
//如果存在多个元素，返回第一个
//如果不存在，返回比它大的数的索引的最小值
int binarySearch(int nums[], int l, int r, int x) {
	while (r >= l && r < nums.length) {
		int mid = (l + r) / 2;
		if (nums[mid] >= x)
			r = mid - 1;
		else
			l = mid + 1;
	}
	return l;
}
```

```java
//如果存在多个元素，返回最后一个
//如果不存在，则返回比它小的数的索引的最大值
int binarySearch(int nums[], int l, int r, int x) {
	while (r >= l && r < nums.length) {
		int mid = (l + r) / 2;
		if (nums[mid] <= x)
			l = mid + 1;
		else
			r = mid - 1;
	}
	return r;
}
```

