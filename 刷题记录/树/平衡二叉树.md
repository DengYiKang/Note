# 平衡二叉树（AVL）

```java
class Node{
    int val;
    int height;
    Node left;
    Node right;
}
class AvlTree{
    Node root;
 	Node findMax(Node t){
        if(t==null) return null;
        if(t.right==null) return t;
        return findMax(t.right);
    }
    Node findMin(Node t){
        if(t==null) return null;
        if(t.left==null) return t;
        return findMin(t.left);
    }
    int getHeight(Node t){
        if(t==null) return -1;
        return t.height;
    }
    Node LL(Node t){
        Node q=t.left;
        t.left=q.right;
        q.right=t;
        t.height=max(getHeight(t.left), getHeight(t.right))+1;
        q.height=max(getHeight(q.left), getHeight(q.right))+1;
        return q;
    }
    Node RR(Node t){
        Node q=t.right;
        t.right=q.left;
        q.left=t;
        t.height=max(getHeight(t.left), getHeight(t.right))+1;
        q.height=max(getHeight(q.left), getHeight(q.right))+1;
        return q;
    }
    Node LR(Node t){
        RR(t.left);
        return LL(t);
    }
    Node RL(Node t){
        LL(t.right);
        return RR(t);
    }
    void insert(Node t, int x){
        if(t==null){
            t=new Node(x);
        }else if(x<t.val){
            insert(t.left, x);
            if(getHeight(t.left)-getHeight(t.right)>1){
                if(x<t.left.val) t=LL(t);
                else t=LR(t);
            }
        }else if(x>t.val){
            insert(t.right, x);
            if(getHeight(t.right)-getHeight(t.left)>1){
                if(x>t.right.val) t=RR(t);
                else t=RL(t);
            }
        }else{
            //数据重复，看情况处理
        }
        t.height=max(getHeight(t.left), getHeight(t.right))+1;
    }
    boolean delete(Node t, int x){
        if(t==null) return false;
        else if(t.val==x){
            if(t.left!=null&&t.right!=null){
                if(getHeight(t.left)>getHeight(t.right)){
                  	t.val=findMax(t.left).val;
                    delete(t.left, t.val);
                }else{
                    t.val=findMin(t.right).val;
                    delete(t.right, t.val);
                }
            }else{
                Node old=t;
                t=t.left!=null?t.left:t.right;
                delete old;
            }
        }else if(x<t.val){
            delete(t.left, x);
            if(getHeight(t.right)-getHeight(t.left)>1){
                if(getHeight(t.right.left)>getHeight(t.right.right)){
                    t=RL(t);
                }else{
                    t=RR(t);
                }
            }else{
                t.height=max(getHeight(t.left), getHeight(t.right))+1;
            }
        }else{
            delete(t.right, x);
            if(getHeight(t.left)-getHeight(t.right)>1){
                if(getHeight(t.left.right)>getHeight(t.left.left)){
                    t=LR(t);
                }else{
                    t=LL(t);
                }
            }else{
                t.height=max(getHeight(t.left), getHeight(t.right))+1;
            }
        }
        return true;
    }
}
```

