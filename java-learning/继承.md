# 继承

## 类、超类、子类

### 定义子类

```java
public Employee{
    private double salary;
}
public class Manager extends Employee{
    private double bonus;
    public double getSalary(){
        
    }
}
```

已存在的类称为超类、基类或父类；新类称为子类、派生类。

注意父类不能调用子类独有的方法。而子类可以调用超类的方法。

==注意==：在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。

### 覆盖方法

新方法覆盖超类同名中的方法：

```java
public class Manager extends Employee{
    ...;
    public double getSalary(){
        return salary+bonus;
    }
}
```

然而这个方法无法运行。==因为子类的方法不能直接访问超类的私有域。==

下面方法也不行：

```java
public double getSalary(){
    double baseSalary=getSalary();//死循环
    return baseSalary+bonus;
}
```

可以使用关键词super解决问题：

```java
super.getSalary();
```

==注释==：有些人认为super与this引用是类似的概念。不恰当。因为super不是一个对象的引用，不能将super赋给其他对象变量。

### 子类构造器

```java
public Manager(String name, double salary, int year, int month, int day){
    super(name, salary, year, month, day);
    bonus=0;
}
```

由于子类不能访问超类的私有域，因此必须用超类的构造器。

==注==：关键词this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样super关键词也有两个用途：一是调用超类方法，二是调用超类的构造器。

### 继承层次

由一个公共超类派生出来的所有类的集合称为继承层次（**inheritance hierarchy**）。在继承层次中，从某个特定类到祖先的路径被称为该类的继承链（**inheritance chain**）。

### 多态

可以将一个子类对象赋给超类变量：

```java
Employee e;
e=new Employee();
e=new Manager();
```

对象变量是多态的.一个超类既可以引用其本身，也可以引用其任何一个子类的对象。

```java
Manager boss=new Manager(...);
Employee[] staff=new Employee[3];
staff[0]=boss;
boss.setBonus(...);//OK
staff[0].setBonus(...);//Error
```

不能将一个超类的引用赋给子类变量。如：

```java
Manager m=staff[i];//Error
```

### 理解方法调用

x.f(param)调用过程如下：

+ 编译器查看对象的声明类型和方法名，获得所有可能被调用的候选方法。
+ 编译器查看调用方法时提供的参数类型。这个过程称为重载解析（**overloading resolution**）。至此，编译器已获得需要调用的方法名字和参数类型。
+ 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。
+ 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D的超类中寻找f(String)，以此类推。

==注==：方法的名字和参数列表称为方法的签名。返回类型不是签名的一部分。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，虚拟机查表即可。

方法表示例：

```java
Manager：
    getName()->Employee.getName()
    getSalary()->Manager.getSalary()
    setBonus(double)->Manager.setBonus(double)
```

==警告==：在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法应声明为public。

### 阻止继承：final类和方法

不允许扩展的类被称为final类。

```java
public final class Executive extends Manager{
    ...
}
```

类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（==final类中所有方法自动称为final方法，但不包括域==）。