# 继承

## 类、超类、子类

### 定义子类

```java
public Employee{
    private double salary;
}
public class Manager extends Employee{
    private double bonus;
    public double getSalary(){
        
    }
}
```

已存在的类称为超类、基类或父类；新类称为子类、派生类。

注意父类不能调用子类独有的方法。而子类可以调用超类的方法。

==注意==：在Java中，所有的继承都是公有继承，而没有C++中的私有继承和保护继承。

### 覆盖方法

新方法覆盖超类同名中的方法：

```java
public class Manager extends Employee{
    ...;
    public double getSalary(){
        return salary+bonus;
    }
}
```

然而这个方法无法运行。==因为子类的方法不能直接访问超类的私有域。==

下面方法也不行：

```java
public double getSalary(){
    double baseSalary=getSalary();//死循环
    return baseSalary+bonus;
}
```

可以使用关键词super解决问题：

```java
super.getSalary();
```

==注释==：有些人认为super与this引用是类似的概念。不恰当。因为super不是一个对象的引用，不能将super赋给其他对象变量。

### 子类构造器

```java
public Manager(String name, double salary, int year, int month, int day){
    super(name, salary, year, month, day);
    bonus=0;
}
```

由于子类不能访问超类的私有域，因此必须用超类的构造器。

==注==：关键词this有两个用途：一是引用隐式参数，二是调用该类其他的构造器。同样super关键词也有两个用途：一是调用超类方法，二是调用超类的构造器。

### 继承层次

由一个公共超类派生出来的所有类的集合称为继承层次（**inheritance hierarchy**）。在继承层次中，从某个特定类到祖先的路径被称为该类的继承链（**inheritance chain**）。

### 多态

可以将一个子类对象赋给超类变量：

```java
Employee e;
e=new Employee();
e=new Manager();
```

对象变量是多态的.一个超类既可以引用其本身，也可以引用其任何一个子类的对象。

```java
Manager boss=new Manager(...);
Employee[] staff=new Employee[3];
staff[0]=boss;
boss.setBonus(...);//OK
staff[0].setBonus(...);//Error
```

不能将一个超类的引用赋给子类变量。如：

```java
Manager m=staff[i];//Error
```

### 理解方法调用

x.f(param)调用过程如下：

+ 编译器查看对象的声明类型和方法名，获得所有可能被调用的候选方法。
+ 编译器查看调用方法时提供的参数类型。这个过程称为重载解析（**overloading resolution**）。至此，编译器已获得需要调用的方法名字和参数类型。
+ 如果是private方法、static方法、final方法或者构造器，那么编译器将可以准确地知道应该调用哪个方法，这种调用方式称为静态绑定。与此对应，调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定。
+ 当程序运行，并且采用动态绑定调用方法时，虚拟机一定调用与x所引用对象实际类型最合适的那个类的方法。假设x的实际类型是D，它是C类的子类。如果D类定义了方法f(String)，就直接调用它；否则，将在D的超类中寻找f(String)，以此类推。

==注==：方法的名字和参数列表称为方法的签名。返回类型不是签名的一部分。

每次调用方法都要进行搜索，时间开销相当大。因此，虚拟机预先为每个类创建了一个方法表，虚拟机查表即可。

方法表示例：

```java
Manager：
    getName()->Employee.getName()
    getSalary()->Manager.getSalary()
    setBonus(double)->Manager.setBonus(double)
```

==警告==：在覆盖一个方法时，子类方法不能低于超类方法的可见性。特别是，如果超类方法是public，子类方法应声明为public。

### 阻止继承：final类和方法

不允许扩展的类被称为final类。

```java
public final class Executive extends Manager{
    ...
}
```

类中的特定方法也可以被声明为final。如果这样做，子类就不能覆盖这个方法（==final类中所有方法自动称为final方法，但不包括域==）。

### 强制类型转换

```java
//将数组中引用Manager类的元素复原成Manager类，以便能够访问新增加的所有变量
Manager boss=(Manager) staff[0];
```

如果试图在继承链上进行向下的类型转换，则会报错，并产生一个ClassCastException异常：

```java
Manager boss=(Manager) staff[1];//Error
```

在进行类型转换之前，先查看一下是否能够成功地转换：

```java
if(staff[1] instanceof Manager){
    boss=(Manager) staff[1];
}
```

### 抽象类

对于一些祖先类，人们只将它作为派生其他类的基类，而不作为想使用的特定的实例。这是可以使用abstract修饰方法，这样就不需要实现该方法。

```java
public abstract String getDescription();
//no implementation method
```

为了提高程序的清晰度，包含一个或多个抽象方法的类本身必须被声明为抽象的：

```java
public abstract class Person{
    public abstract String getDescription();
    ...;
}
```

除了抽象方法外，抽象类还可以包含具体数据和具体方法：

```java
public abstract class Person{
    private String name;
    public Person(String name){
        this.name=name;
    }
    public abstract String getDescription();
    public String getName(){
        return name;
    }
}
```

==提示==：许多程序员认为，在抽象类中不能包含具体的方法。

扩展抽象类有两种选择：

+ 在抽象类中定义部分抽象类方法或不定义抽象类方法，这样子类必须也标记为抽象类。
+ 定义全部的抽象方法，子类就不是抽象类。

类即使不含抽象方法，也可以将类声明为抽象类。

抽象类不能实例化，如：

```java
new Person("Vince");//Error
```

需要注意，可以定义一个抽象类的对象变量，但是它只能引用非抽象子类的对象：

```java
Person p=new Student(...);
```

下面定义一个非抽象子类Student:

```java
public class Student extends Person{
    private String major;
    public Student(String name, String major){
        super(name);
        this.major=major;
    }
    public String getDescription(){
        return "a student majoring is"+major;
    }
}
```

再看下面代码:

```java
Person[] people=new Person[2];
people[0]=new Employee(...);
people[1]=new Student(...);
for(Person p:people){
    System.out.println(p.getName+","+p.getDescription());
}
```

注意这一行代码：

```java
System.out.println(p.getName+","+p.getDescription());
```

**p.getDescription()**在Person类中是抽象的，但是变量p引用的是其具体子类对象，而这些对象都定义了getDescription方法。那么，是否可以省略Person超类中的抽象方法，而仅在Employee和Student子类中定义getDescription方法呢？如果这样的话，就不能通过变量p调用getDescription方法了。编译器只允许调用在类中声明的方法。

### 受保护访问

Java用于控制可见性的4个访问修饰符：

+ 仅对本类可见——private
+ 对所有类可见——public
+ 对本包和所有子类可见——protected
+ 对本包可见——默认，不需要修饰符

## Object：所有类的超类

Object类是Java中所有类的超类，但并不需要这样写：

```java
public class Employee extends Object
```

如果没有明确指出超类，Object就被认为是其超类。

可以使用Object类型的变量引用任何类型的对象：

```java
Object obj=new Employee(...);
//如果想对其中的内容进行具体的操作，还需要清楚对象的原型，并进行类型转换
Employee e=(Employee) obj;
```

在Java中，只有基本类型不是对象。

所有的数组类型，不管是对象数组还是基本类型的数组都扩展了Object类：

```java
Employee[] staff=new Employee[10];
Object obj=staff;//OK
obj=new int[10];//OK
```

==注==：在C++中没有所有类的根类，不过每个指针都可以转换成void*类型。

### equals方法

在Object类中，这个方法将判断两个对象是否有相同的引用。然而对大多数类而言，这种判断没有意义，因为经常需要检测两个对象的状态的相等性，如各种属性等。

```java
public class Employee{
    ...;
    public boolean equals(Object otherObj){
        //a quick test to see if the objs are identical
        if(this==otherObj) return true;
        //must return false if the explicit parameter is null
        if(otherObj==null) return false;
        //if the classes don't match, they can't be equal
        if(getClass()!=otherObj.getClass()) return false;
        //now we know otherObj is a non-null Employee
        Employee other=(Employee) otherObj;
        //test whether the fields have identical values
        return name.equals(other.name)
            &&salary==other.salary
            &&hireDay.equals(other.hireDay);
    }
}
```

==注意==：为了防备name或hireDay可能为null的情况，需要使用Object.equals方法。如果两个参数都为null，Object.equals(a, b)调用将返回true；如果其中一个参数为null，则返回false；否则如果两个参数都不为null，则调用a.equals(b)。则上述代码的最后一句要改写为：

```java
return Object.equals(name, other.name)
    &&salary==other.salary
    &&Object.equals(hireDay, other.hireDay);
```

在子类定义equals方法时，首先调用超类的equals。如果检测失败，对象就不可能相等。

```java
public class Manager extends Employee{
    ...;
    public boolean equals(Object otherObj){
        if(!super.equals(otherObj)) return false;
        Manager other=(Manager) otherObj;
        return bonus==other.bonus;
    }
}
```

### 相等测试与继承

如果隐式和显示的参数不属于同一个类，equals方法将如何处理？

Java语言规范要求equals方法具有下面特性：

+ 自反性：对于任何非空引用x，x.equals(x)应返回true。
+ 对称性：x.equals(y)等价于y.equals(x)。
+ 传递性：若x.equals(y)=x.equals(y)=true，则x.equals(z)=true。
+ 对于任何非空引用x，x.equals(null)=false。

可以从两个不同的情况看待问题：

+ 如果子类能够拥有自己相等的概念，则对称性需求将强制采用getClass进行检测。
+ 如果由超类决定相等的概念，那么就可以使用instanceof检测。

如，假设使用雇员ID作为相等的检测标准，并且这个相等的概念适用于所有的子类，就可以使用instanceof进行检测，并应该将Employee.equals声明为final。

==下面给出编写equals方法的建议：==

+ 显示参数命名为otherObject，稍后需要将它转换成另一个叫做other的变量。

+ 检测this与otherObject是否引用同一个对象：

  ```java
  if(this==otherObject) return true;
  ```

+ 检测otherObject是否为null：

  ```java
  if(otherObject==null) return false;
  ```

+ 比较this与otherObject是否属于同一个类。如果equals的语义在每个子类中有所改变，就使用getClass检测：

  ```java
  if(getClass()!=otherObject.getClass()) return false;
  ```

  如果所有的子类都拥有统一的语义，就使用instanceof检测：

  ```java
  if(!(otherobject instanceof ClassName)) return false;
  ```

+ 将otherObject转换为相应的类类型变量：

  ```java
  ClassName other=(ClassName) otherObject;
  ```

+ 比较域。用==比较基本类型域，使用equals比较对象域：

  ```java
  return field1==other.field1
      && Objects.eauqls(field2, other.field2);
  ```

  如果在子类重新定义equals，就要在其中包含调用super.equals(other)。

==警告==：下面是实现equals方法的一种常见的错误：

```java
public class Employee{
    public boolean equals(Employee other){
        return other!=null
            && getClass()!=other.getClass()
            && Objects.equals(name, other,name)
            && salary==other.salary
            && Objects.equals(hireDay, other.hireDay);
    }
}
```

这个方法声明的显示参数类型是Employee。其结果并没有覆盖Object类的equals方法，而是定义了一个完全无关的方法。

为了避免发生类型错误，可以使用@Override对覆盖超类的方法进行标记：

```java
@Override public boolean equals(Object other)
```

如果出现了错误，并且正在定义一个新方法，编译器就会给出错误报告。例如，假设将下面的声明添加到Employee类中:

```java
@Override public boolean equals(Employee other)
```

就会看到一个错误报告，这是因为这个方法并没有覆盖超类Object中的任何方法。

```java
java.util.Arrays 1.2;
static Boolean equals(type[] a, type[] b);
/*如果两个数组长度相同，并且在对应的位置上数据元素也相同，将返回true。类型可以是Object和基本类型*/
```

```java
java.util.Objects 7;
static boolean equals(Object a, Object b);
/*如果a和b都为null，返回true；如果只有其中之一为null，则返回false；否则返回a.equals(b)*/
```





